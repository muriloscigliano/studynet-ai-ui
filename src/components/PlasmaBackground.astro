---
// Ether plasma shader from ShaderToy
---
<canvas id="plasma-canvas"></canvas>

<script>
  function initPlasma() {
    const canvas = document.getElementById('plasma-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    const glContext = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!glContext) {
      console.error('WebGL not supported');
      return;
    }
    const gl = glContext as WebGLRenderingContext;

    // Resize canvas
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    resize();
    window.addEventListener('resize', resize);

    // Vertex shader
    const vertexShader = gl.createShader(gl.VERTEX_SHADER)!;
    gl.shaderSource(vertexShader, `
      attribute vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      console.error('Vertex shader error:', gl.getShaderInfoLog(vertexShader));
      return;
    }

    // Fragment shader - Ether by nimitz (customized colors)
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;
    gl.shaderSource(fragmentShader, `
      precision highp float;
      uniform vec2 iResolution;
      uniform float iTime;
      uniform float isDarkMode;

      #define t iTime
      mat2 m(float a){float c=cos(a), s=sin(a);return mat2(c,-s,s,c);}
      float map(vec3 p){
          p.xz*= m(t*0.15);p.xy*= m(t*0.12);  // Slower: reduced from 0.4/0.3 to 0.15/0.12
          vec3 q = p*2.+t*0.4;  // Slower overall time progression
          return length(p+vec3(sin(t*0.3)))*log(length(p)+1.) + sin(q.x+sin(q.z+sin(q.y)))*0.5 - 1.;
      }

      void main(){	
        vec2 fragCoord = gl_FragCoord.xy;
        vec2 p = fragCoord.xy/iResolution.y - vec2(.9,.5);
        vec3 cl = vec3(0.);
        float d = 2.5;
        
        // Dark mode colors (purple/magenta theme)
        vec3 baseColorDark = vec3(0.08, 0.07, 0.13);  // Dark blue-purple like --bg
        vec3 accentColorDark = vec3(2.5, 0.8, 1.5);   // Magenta/purple like --primary
        
        // Light mode colors (soft, muted)
        vec3 baseColorLight = vec3(0.55, 0.55, 0.58);  // Soft gray-purple
        vec3 accentColorLight = vec3(1.2, 0.5, 0.8);   // Muted pink/purple
        
        // Blend colors based on theme
        vec3 baseColor = mix(baseColorLight, baseColorDark, isDarkMode);
        vec3 accentColor = mix(accentColorLight, accentColorDark, isDarkMode);
        
        for(int i=0; i<=5; i++)	{
          vec3 p = vec3(0,0,5.) + normalize(vec3(p, -1.))*d;
          float rz = map(p);
          float f =  clamp((rz - map(p+.1))*0.5, -.1, 1. );
          vec3 l = baseColor + accentColor*f;
          cl = cl*l + smoothstep(2.5, .0, rz)*.7*l;
          d += min(rz, 1.);
        }
        gl_FragColor = vec4(cl, 1.);
      }
    `);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      console.error('Fragment shader error:', gl.getShaderInfoLog(fragmentShader));
      return;
    }

    // Create program
    const program = gl.createProgram()!;
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(program));
      return;
    }
    gl.useProgram(program);

    // Create fullscreen quad
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

    const position = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(position);
    gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

    const iResolution = gl.getUniformLocation(program, 'iResolution');
    const iTime = gl.getUniformLocation(program, 'iTime');
    const isDarkMode = gl.getUniformLocation(program, 'isDarkMode');

    // Check theme from document
    function getThemeValue() {
      const theme = document.documentElement.getAttribute('data-theme');
      return theme === 'dark' ? 1.0 : 0.0;
    }

    // Watch for theme changes
    const observer = new MutationObserver(() => {
      // Theme changed, will be picked up in next render
    });
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['data-theme']
    });

    // Animation
    const startTime = Date.now();
    function render() {
      const time = (Date.now() - startTime) / 1000;
      gl.uniform2f(iResolution, canvas.width, canvas.height);
      gl.uniform1f(iTime, time);
      gl.uniform1f(isDarkMode, getThemeValue());
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      requestAnimationFrame(render);
    }
    render();

    console.log('âœ… Plasma initialized');
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPlasma);
  } else {
    initPlasma();
  }
</script>

<style is:global>
  #plasma-canvas {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    z-index: 0 !important;
    opacity: 0.5 !important;
    pointer-events: none !important;
    display: block !important;
  }

  [data-theme="light"] #plasma-canvas {
    opacity: 0.2 !important;
  }

  /* Ensure parent containers can contain the absolute canvas */
  .page, .login-page {
    position: relative;
  }
  
  /* Ensure content is above plasma */
  .shell, .main, .sidebar, 
  .login-page-header, .login-page-main {
    position: relative;
    z-index: 1;
  }
</style>
